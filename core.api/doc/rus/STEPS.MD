# Инструменты построения/описания шагов

В данном документе описана реализация тезисов, перечисленных [здесь](./README.MD)

## Контекст

Контекст предназначен для инкапсуляции объектов, которые могут быть использованы как входные 
данные функций-шагов. Например, это могут быть:

- открытая сессия WebDriver'а, 
- открытые соединения с базами данных
- работающий http-клиент

и т.д.

Так же он отделяет логику шагов от логики инициализации ресурсов для их выполнения.

```java
package org.my.pack;

import ru.tinkoff.qa.neptune.core.api.steps.context.Context;
import ru.tinkoff.qa.neptune.core.api.steps.context.CreateWith;

//Формирует параметры вызова конструктора
//Предполагается, что для этого используются значения различных переменных окружения
//среды, в которой выполняются тесты
@CreateWith(provider = MyParameterProvider.class)
//Если конструктор аннотируемого класса не имеет параметров, аннотацию можно не 
//указывать
public class MyTestContext extends Context<MyTestContext> { //generic сигнатура для того,
    //чтобы ограничить возможность шагам для других контекстов использовать 
    //объекты данного класса
    
    //Рекомендуемый способ доступа до объектов контекста
    public static MyTestContext myTestContext() {
        return getInstance(MyTestContext.class);
    }
    
    //Конструктор может содержать параметры
    protected MyTestContext(/*Параметры*/) {
        //Логика инициализации
    }

    //пример
    public Object getSomeResource() {
        return //Возврат какого-нибудь проинициализированного объекта
        //для использования в шагах (рекомендуется)
        //для использования напрямую (не рекомендуется)
    }
}
```

```java
package org.my.pack;

import ru.tinkoff.qa.neptune.core.api.steps.context.ParameterProvider;

public class MyParameterProvider implements ParameterProvider {
    
    @Override
    public Object[] provide() {
        //Создает параметры вызова конструктора MyTestContext
    }
}
```

## Шаги

### Произвольные шаги, которые могут быть описаны в тесте

Данный механизм можно использовать, чтобы сгруппировать в коде/логе/репорте
множество простых действий или шагов в один произвольный шаг верхнего уровня.

```java
package org.my.pack;

import org.testng.annotations.Test;

import static ru.tinkoff.qa.neptune.core.api.steps.Step.$;

public class SomeTest {
    
    @Test
    public void test() {
        //Шаг просто выполняется и ничего не возвращает
        $("Given: что-то в некотором состоянии", () -> {
            //Некоторые действия
        });
        
        //Шаг выполняется и возвращает какое-то значение
        var result = $("When: что-то делаем и получаем", () -> {
            //Некоторые действия
            return //возврат некоторого значения
        });
        
        $("Then: проверяем то, что получили", () -> {
            assetThat(result, /*Параметры проверки*/);
        });
    }
}
```

Ниже речь пойдет о механизме, при помощи которого можно описать базовый набор шагов для того
или иного контекста.

### Шаги, которые возвращают результат

Для описания набора действий с возвратом некоторого результата в рамках некоторого действия используется 
наследники `ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier`. Ниже пример, демонстрирующий
работу и принцип данного класса.

```java
package org.my.pack;

import ru.tinkoff.qa.neptune.core.api.steps.Criteria;
import ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier;
import ru.tinkoff.qa.neptune.core.api.steps.annotations.ThrowWhenNoData;

import java.time.Duration;
import java.util.function.Function;
import java.util.function.Predicate;

//Данный класс строит шаг, работающий по принципу функции.
// Входным значением является объект-контекст, содержащий нужные ресурсы для выполнения.
// Выходное значение получается напрямую от входного, или опосредованно через значение типа M,
// полученного от входного значения.
//
// На получение результата типа T от M нужно некоторое время, с некоторой паузой между попытками
// получить желаемый результат.
//
// Результат типа T должен соответствовать некоторым критериям, которые проверяют результат по значению
// типа P.

//Здесь описывается исключение, которое может быть выброшено, если в результате выполнения
//не было получено значение, соответствующее указанным критериям, и за указанное время.
//Указывается класс исключения, у которого есть публичный конструктор с параметром типа
//String (текст сообщения). В данном примере может быть выброшено IllegalStateException,
//с текстом Can't get: <описание получаемого значения и параметров шага, об этом будет ниже>
//Аннотацию можно не указывать, т.к. по умолчанию может быть выброшено
// ru.tinkoff.qa.neptune.core.api.steps.NotPresentException с текстом "Not present: <текст>"
@ThrowWhenNoData(toThrow = IllegalStateException.class, startDescription = "Can't get:")
public class MyGetStepSupplier<T, M, P>
        extends SequentialGetStepSupplier<
        MyTestContext, //Тип входного параметра для результирующей функции-шага.
        //Как правило это контекст, в рамках которого данное действие может быть выполнено
        T, //Тип результата, который должна возвращать функция-шаг
        M, //Часто бывает так, что результат получается не через прямые вычисления от входного
        //параметра, а через некоторое промежуточное значение, полученное от входного параметра.
        //Данный параметр - это тип промежуточного значения, от которого может быть получен нужный
        //результат. Данный параметр необходим, чтобы, входным параметром могла быть функция
        //Function<MyTestContext, M>, построенная аналогичным GetStepSupplier'ом
        P, //Тип значения, которое используется при проверке результата через указанные критерии
        MyGetStepSupplier<T, M, P>> //здесь желательного указывать тип самого класса или расширяющий
        //тип. Наследники SequentialGetStepSupplier работают как Builder, и многие методы
        //возвращают ссылку на объект, от которого ини были вызваны
{

    @Override
    protected Function<M, T> getEndFunction() {
        return //подготовка функции, которая НЕПОСРЕДСТВЕННО возвращает
        //конечный результат
    }

    //Если конечный результат, соответствующий критериям, может быть
    //возвращен не сразу, то следует предусмотреть возможность
    //указывать приемлемый интервал времени, за который этот результат
    //должен быть получен. Как в примере ниже.
    //Функция, возвращенная методом `protected Function<M, T> getEndFunction()`
    //будет выполняться циклически в рамках указанного интервала времени,
    //пока не будет получен нужный результат, или не будет выброшено исключение,
    //которое нельзя игнорировать.
    @Override
    public MyGetStepSupplier<T, M, P> timeOut(Duration timeOut) {
        return super.timeOut(timeOut);
    }

    //Если между попытками получить необходимый результат нужно делать паузу
    //(в рамках отведенного времени), то надо иметь возможность
    //указывать продолжительность этой паузы. Как в примере ниже.
    @Override
    public MyGetStepSupplier<T, M, P> pollingInterval(Duration pollingTime) {
        return super.pollingInterval(pollingTime);
    }

    // В процессе вычислений функция, возвращенная методом `protected Function<M, T> getEndFunction()`,
    // может возвращать результат, который на самом деле не соответствует некоторым нашим ожиданиям.
    // Если такое может происходить, следует предусмотреть возможность указывать критерии, которым
    // должен соответствовать возвращаемый результат.
    @Override
    public MyGetStepSupplier<T, M, P> criteria(Criteria<? super P> criteria) {
        return super.criteria(criteria);
    }

    // Аналогично примеру выше. В данном случае критерий задается в виде предиката с пояснительным
    // описанием критерия
    @Override
    public MyGetStepSupplier<T, M, P> criteria(String description, Predicate<? super P> predicate) {
        return super.criteria(description, predicate);
    }

    // здесь можно описать действия, выполняемые после того, как промежуточное значение
    // типа M было получено, до того как вычисление результата началось.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    // Объект-посредник можно проигнорировать. Но если с ним что-то надо сделать в этом
    // методе важно знать, что сюда может прийти null, пустой массив или объект Iterable,
    // если в ходе его вычисления ничего подходящего не было получено.
    @Override
    protected void onStart(M m) {
        //Какая-то логика
    }

    // здесь можно описать действия, выполняемые после того, как результат был вычислен,
    // и никакое исключение не было выброшено.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    // Результирующее значение можно проигнорировать. Но если с ним что-то надо сделать в этом
    // методе важно знать, что сюда может прийти null, пустой массив или объект Iterable,
    // если за указанное время ничего подходящее под описанные критерии не было получено.
    @Override
    protected void onSuccess(T t) {
        //Какая-то логика
    }


    // здесь можно описать действия, выполняемые после того, как было выброшено
    // исключение, которое либо не удалось проигнорировать в процессе вычисления,
    // либо было выброшено потому, что выполнение шага не дало ожидаемого результата.
    // Объект-посредник можно проигнорировать. Но если с ним что-то надо сделать в этом
    // методе важно знать, что сюда может прийти null, пустой массив или объект Iterable,
    // если в ходе его вычисления ничего подходящего не было получено.
    @Override
    protected void onFailure(M m, Throwable throwable) {
        //Какая-то логика
    }

    @Override //Результирующая функция-шаг возвращается данным методом
    public Function<MyTestContext, T> get() {
        return super.get();
    }
}
```

Данный пример демонстрирует принцип работы. В большинстве случаев рекомендуется воспользоваться одним из 
классов — наследников `ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier` согласно одной из часто 
встречающихся ситуаций.

#### Критерии

### Шаги, которые выполняют действие

### Присутствие и отсутствие

## Вложенность/глубина шагов